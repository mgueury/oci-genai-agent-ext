-- DROP TABLE docs;
CREATE TABLE APEX_APP.docs (
    id NUMBER GENERATED by default on null as IDENTITY,
    status varchar2(256),
    content CLOB,
    summary CLOB,
    translation CLOB,
    summary_embed vector,
    resource_name varchar2(1024), -- File that caused the event to trigger.
    original_resource_name varchar2(1024), -- Original file that caused the event to trigger.
    path varchar2(1024),    
    content_type varchar2(256),
    region varchar2(256),    
    application_name varchar2(256),
    author varchar2(256),
    creation_date varchar2(256),    
    modified varchar2(256),    
    category1 varchar2(1024),    
    category2 varchar2(1024),    
    category3 varchar2(1024),    
    parsed_by varchar2(256),    
    title varchar2(1024),
    source_type varchar2(256),
    file_blob BLOB                       -- New Uploaded file 
);
alter table "APEX_APP"."DOCS" add constraint "DOCS_PK" primary key ( "ID" );

create or replace trigger APEX_APP.DOCS_TRIGGER_INSERT_UPDATE
before insert or update on APEX_APP.DOCS for each row
declare
  v_path varchar2(1024) := '';
begin
    if :new.file_blob is not null and :new.status='NEW' then
        if LENGTH(nvl(:new.path,''))>0 then
            :new.resource_name := :new.path || '/' || :new.resource_name;
        end if;
        :new.original_resource_name := :new.resource_name;
        :new.path := ai_plsql.upload_blob_to_object_storage( :new.file_blob, :new.resource_name );        
        :new.source_type := 'OBJECT_STORAGE';
    end if;   
end;
/
/
create or replace trigger APEX_APP.DOCS_TRIGGER_DELETE
before delete on APEX_APP.DOCS for each row
begin
    if :OLD.PATH LIKE 'https://objectstorage%' and :old.resource_name=:old.original_resource_name then 
        ai_plsql.delete_blob_from_object_storage( :old.resource_name );
    end if;
end;
/

CREATE TABLE APEX_APP."DOCS_LANGCHAIN" (
    id RAW(16) DEFAULT SYS_GUID(), 
	text CLOB, 
	metadata JSON, 
	embedding VECTOR, 
    -- FILTER_COLUMNS
    doc_id number,
    path VARCHAR2(1024),
    resource_name VARCHAR2(1024),
    page_label VARCHAR2(1024),
    category1 VARCHAR2(1024),
    category2 VARCHAR2(1024),
    category3 VARCHAR2(1024),
    text_length NUMBER
	PRIMARY KEY ("ID")
);

CREATE OR REPLACE TRIGGER APEX_APP.docs_langchain_trigger
BEFORE INSERT OR UPDATE ON APEX_APP.docs_langchain_index
FOR EACH ROW
BEGIN
  -- Extract JSON values to populate columns
  -- This is needed to get better speed for Vector Filtering index
  :NEW.doc_id        := JSON_VALUE(:NEW.metadata, '$.doc_id');
  :NEW.path          := JSON_VALUE(:NEW.metadata, '$.path');
  :NEW.resource_name := JSON_VALUE(:NEW.metadata, '$.resource_name');
  :NEW.page_label    := JSON_VALUE(:NEW.metadata, '$.page_label');
  :NEW.category1     := JSON_VALUE(:NEW.metadata, '$.category1');
  :NEW.category2     := JSON_VALUE(:NEW.metadata, '$.category2');
  :NEW.category3     := JSON_VALUE(:NEW.metadata, '$.category3');      
  :NEW.text_length   := LENGTH(:NEW.text);      
END;
/

CREATE INDEX APEX_APP.docs_langchain_ctx_index on APEX_APP.docs_langchain( text ) indextype is ctxsys.context;  
CREATE INDEX APEX_APP.docs_langchain_category1_index on APEX_APP.docs_langchain( category1 );  
CREATE VECTOR INDEX APEX_APP.docs_langchain_hnsw_idx ON APEX_APP.docs_langchain(embedding) ORGANIZATION INMEMORY NEIGHBOR GRAPH DISTANCE COSINE WITH TARGET ACCURACY 95;

-- Helper view for debugging
create view APEX_APP.V_DOCS_LANGCHAIN as
    select 
        JSON_VALUE(metadata,'$.path') as URL,            
        metadata,
        JSON_VALUE(metadata,'$.doc_id') as DOCID, 
        JSON_VALUE(metadata,'$.file_name') as TITLE, 
        text as BODY, 
        id as CHUNKID, 
        TO_NUMBER(JSON_VALUE(metadata,'$.page_label')) as PAGE_NUMBERS      
    from APEX_APP.docs_langchain;

-- DROP TABLE docs_chunck;
/*
CREATE TABLE APEX_APP.docs_chunck (
    id NUMBER GENERATED by default on null as IDENTITY,
    doc_id number,
    fileblob BLOB, -- Null when the file is outside of the DB, allow upload of files with for ex APEX
    content CLOB,
    translation CLOB,
    embed vector(1024),
    resource_name varchar2(256),    
    path varchar2(1024),    
    content_type varchar2(256),
    region varchar2(256),    
    page integer,
    char_start integer,
    char_end integer,
    summary CLOB
);
alter table "APEX_APP"."DOCS_CHUNCK" add constraint "DOCS_CHUNCK_PK" primary key ( "ID" );
alter table "APEX_APP"."DOCS_CHUNCK" add constraint "DOCS_FK" foreign key ( "DOC_ID" ) references "APEX_APP.DOCS" ( "ID" ) on delete cascade;
create index APEX_APP.docs_index on APEX_APP.docs_langchain( text ) indextype is ctxsys.context;  
*/

-- UPDATE AI_CONFIG
CREATE OR REPLACE PROCEDURE APEX_APP.AI_CONFIG_UPDATE( p_key IN VARCHAR2,p_value IN VARCHAR2)  IS
    n number;
begin
    select count(*) into n from AI_AGENT_RAG_CONFIG where key=p_key;
    IF n=0 THEN
      insert into APEX_APP.AI_AGENT_RAG_CONFIG( key, value ) values( p_key, p_value );
    else 
      update APEX_APP.AI_AGENT_RAG_CONFIG set value=p_value where key=p_key;
    end if;
end;    
/

create or replace function retrieval_func( p_query IN VARCHAR2,top_k IN NUMBER, p_filter_category1 in VARCHAR2 default null ) RETURN SYS_REFCURSOR IS
    v_results SYS_REFCURSOR;
    cleaned_query varchar2(4096);
    g_rag_search_type varchar2(256);
begin
    -- Simple Vector query 
    select value into g_rag_search_type from AI_AGENT_RAG_CONFIG where key='rag_search_type'; 
    if g_rag_search_type='vector' then 
      OPEN v_results FOR
        select 
            JSON_VALUE(metadata,'$.doc_id') as DOCID, 
            text as BODY, 
            vector_distance(embedding, to_vector(ai_plsql.genai_embed( p_query ))) AS SCORE,
            id as CHUNKID, 
            JSON_VALUE(metadata,'$.file_name') as TITLE, 
            JSON_VALUE(metadata,'$.path') as URL,
            '[' || JSON_VALUE(metadata,'$.page_label') || ']' as PAGE_NUMBERS    
            -- NUMBER_TT( TO_NUMBER(JSON_VALUE(metadata,'$.page_label')) ) as PAGE_NUMBERS   
            -- TO_NUMBER(1) as PAGE_NUMBERS   
        from docs_langchain
        where p_filter_category1 is null 
           or p_filter_category1 = JSON_VALUE(metadata,'$.category1')
        order by score 
        fetch first top_k rows only;
    else 
      -- Hybrid Search query (30 Lexical/ 70 Vector)
      -- Oracle Text score: 0 - 100.0 (higher is better)
      -- Vector distance : 0 - 1.0 (closer is better)
      -- Clean up the query string to avoid issue with the CONTAINS(xxx), error like ORA-29902 ORA-30600 DRG-50901
      cleaned_query := REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(p_query, '!', ' '), '?', ' '), '#', ' '), '>', ' '), '<', ' ');
      AI_AGENT.LOG( 'P_QUERY', p_query );

      OPEN v_results FOR
        WITH text_search AS (
            SELECT id, score(99)/100 as score FROM docs_langchain
            WHERE CONTAINS(text, cleaned_query, 99)>0 order by score(99) DESC FETCH FIRST top_k ROWS ONLY
        ),
        vector_search AS (

            SELECT id, vector_distance(embedding, to_vector(ai_plsql.genai_embed( p_query ))) AS vector_distance
            FROM docs_langchain
        )
        SELECT 
            JSON_VALUE(metadata,'$.doc_id') as docid, 
            text as BODY,
            (0.3 * ts.score + 0.7 * (1 - vs.vector_distance)) AS score,
            o.id as CHUNKID,
            JSON_VALUE(metadata,'$.file_name') as TITLE, 
            JSON_VALUE(metadata,'$.path') as URL,
            JSON_VALUE(metadata,'$.page_label') as page_numbers             
        FROM docs_langchain o
        JOIN text_search ts ON o.id = ts.id
        JOIN vector_search vs ON o.id = vs.id
        where p_filter_category1 is null 
           or p_filter_category1 = JSON_VALUE(metadata,'$.category1')        
        ORDER BY score DESC
        FETCH FIRST top_k ROWS ONLY;
    end if;
    RETURN v_results;
end retrieval_func;
/

-- Admin function 
CREATE OR REPLACE FUNCTION RETRIEVAL_FUNC (p_query IN VARCHAR2,top_k IN NUMBER) RETURN SYS_REFCURSOR IS
begin
    return APEX_APP.RETRIEVAL_FUNC( p_query, top_k);
end;    
/

/*
insert into DOCS_CHUNCK(
       DOC_ID,
       FILENAME,
       PATH,
       Content,
       embed)
values( 1, 'oracle', 'https://www.oracle.com', 'hello world', ai_plsql.genai_embed('hello_world'));

-- Check the RETRIEVAL_FUNC function
-- Display the DOCID and SCORE

DECLARE
  v_results SYS_REFCURSOR;
  v_docid VARCHAR2(100);
  v_body VARCHAR2(4000);
  v_score NUMBER;
  v_chunck_id VARCHAR2(4000);
  v_title VARCHAR2(4000);
  v_url VARCHAR2(4000);
  v_page_numbers VARCHAR2(4000);
  p_query VARCHAR2(100) := 'what is jazz';
  top_k NUMBER := 10;
BEGIN
  v_results := RETRIEVAL_FUNC(p_query, top_k);
 
  DBMS_OUTPUT.PUT_LINE('DOCID   | SCORE  | URL     | page_numbers');
  DBMS_OUTPUT.PUT_LINE('--------|--------|---------|------------------');
 
  LOOP
    FETCH v_results INTO v_docid, v_body, v_score, v_chunck_id, v_title, v_url, v_page_numbers;
    EXIT WHEN v_results%NOTFOUND;
 
    DBMS_OUTPUT.PUT_LINE(v_docid || ' | ' || v_score || ' | ' || v_url || ' | ' || v_page_numbers);
  END LOOP;
 
  CLOSE v_results;
END; 

*/

exit 
